(function(){
    var a = b = {x:1};
})();
var c = b.x;
console.log(c); //1
//連續賦值，會造成立即函式中的b變數並沒有被宣告，所以b會是一個全域的物件。因為b是一個全域物件，所以外層的c = b.x將會取得b下的x屬性，最終可以得到1的值

// 1. 這行程式碼的關鍵：
// (function(){
//     var a = b = {x:1};
// })();
// (function(){ ... })()：這是一個立即呼叫函式表達式（IIFE），意思是這個匿名函式會被立刻執行。

// var a = b = {x:1};：這行程式碼的行為有些複雜，因為它其實等同於：
// b = {x:1};
// var a = b;
// 這是因為 JavaScript 的賦值運算會從右到左進行，且 var 只會作用於變數 a，而 b 沒有使用 var 聲明，所以：

// a 是區域變數（作用域只在這個 IIFE 裡面）。
// b 成為了全域變數（其實是全域物件 window 或 global 的屬性）。
// 2. 外部程式碼的行為：
// var c = b.x;
// console.log(c);
// 因為 b 在 IIFE 裡被賦值但沒使用 var 聲明，所以它是全域變數，可以在 IIFE 外部被存取。
// b = {x:1}，所以 b.x 的值是 1。
// c = b.x 會取得 1，然後 console.log(c) 也會輸出 1。
// 3. 執行結果： 1
// ✅ 總結：
// a 是區域變數，無法在函式外部存取。
// b 成為了全域變數，因為它沒有被 var、let、const 聲明。
// c 成功取得 b.x，所以 console.log(c) 輸出 1。